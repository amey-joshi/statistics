---
title: "Level-1"
author: "Amey Joshi"
date: "05/12/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(MASS)
library(lattice)

training.data <- read.csv("train.csv")
```

## Candidate variables
Of the $81$ variables in the data set, we chose to retain $36$ after a 
preliminary analysis. In this next stage of analysis, we check if the variables
selected have a strong correlation with each other.

1.  MSSubClass
2.  MSZoning
3.  LotShape
4.  LandContour
5.  LotConfig *combine "Corner","FR2", "Inside" into one*.
6.  Neighborhood * collapse 25 levels into 6*.
7.  Condition1 * collapse 9 levels into 3*.
8.  BldgType * collapse 5 levels into 2*.
9.  HouseStyle *drop it in first model*.
10. OverallQual *collapse first two levels.*
11. OverallCond *drop it in favor of OverallQual.*
12. RoofStyle
13. ExterQual
14. ExterCond
15. Foundation
16. BsmtQual
17. BsmtCond
18. BsmtExposure
19. TotalBsmtSF
20. HeatingQC
21. CentralAir
22. Electrical
23. GrLivArea
24. BsmtFullBath
25. FullBath
26. KitchenQual
27. TotRmsAbvGrd
28. Functional
29. FireplaceQu
30. GarageFinish
31. GarageCond
32. PavedDrive
33. YrSold
34. SaleType
35. SaleCondition
36. SalePrice

## MSSubClass and MSZoning
A contingency table of these variables.
```{r}
with(training.data,
     table(MSSubClass, MSZoning))
```

Even in the heavilty populated 'RL' and 'RM' classes, the data is not evenly 
distributed across MSSubClass. Therefore, the two are not correlated.

## Lot shape and configuration
```{r}
with(training.data, table(LotShape, LotConfig))
```

These variables too do not seem to be correlated. How does mean sale price vary
across them?
```{r}
aggregate(SalePrice ~ LotShape, data = training.data, mean)
aggregate(SalePrice ~ LotConfig, data = training.data, mean)
```

The average sale price for LotConfig values 'Corner', 'FR2' and 'Inside' are quite close to
each other. Let us check if they can be considered to be unequal.
```{r}
oneway.test(SalePrice ~ LotConfig,
            data = training.data,
            subset = LotConfig %in% c("Corner","FR2", "Inside"))
```

The $p$-value indicates that they should be clubbed together in a level 'CF2I'.
```{r}
X <- training.data[, c("LotConfig", "LotShape", "SalePrice")]
# We need as.character because LotConfig is a factor, not a string.
X$LotConfig.1 <- ifelse(X$LotConfig %in% c("Corner","FR2", "Inside"), 
                        "CF2I", 
                        as.character(X$LotConfig))
with(X, table(LotShape, LotConfig.1))
```

Even after collapsing three LotConfig levels into one, there is not corelation
between the two variables. We, therefore, retain both, the second one after
combining levels.


## Land contour
Average sale price varies by land contour as
```{r}
aggregate(cbind(avg.price = SalePrice) ~ LandContour, 
          data = training.data, 
          mean)
```

The division seems quite sharp and so far I haven't discovered another variable
that could be related to it. We will retain it.

## Neighborhood
Average sale price varies with neighborhood as
```{r}
X <- aggregate(cbind(avg.price = SalePrice) ~ Neighborhood,
          data = training.data,
          mean)
X[order(X$avg.price), ]
```

Although the group means are different, there is scope to collapse the 
neighborhoods into fewer number of classes.
```{r}
oneway.test(
  SalePrice ~ Neighborhood,
  data = training.data,
  subset = Neighborhood %in% c("MeadowV", "IDOTRR", "BrDale")
)
oneway.test(
  SalePrice ~ Neighborhood,
  data = training.data,
  subset = Neighborhood %in% c("BrkSide", "Edwards", "OldTown")
)
oneway.test(
  SalePrice ~ Neighborhood,
  data = training.data,
  subset = Neighborhood %in% c("SWISU", "Blueste", "Sawyer", "NPkVill", "NAmes", "Mitchel")
)
oneway.test(
  SalePrice ~ Neighborhood,
  data = training.data,
  subset = Neighborhood %in% c("CollgCr", "Blmngtn", "Gilbert", "NWAmes", "SawyerW")
)
oneway.test(
  SalePrice ~ Neighborhood,
  data = training.data,
  subset = Neighborhood %in% c("Somerst", "ClearCr", "Crawfor", "Veenker", "Timber")
)
oneway.test(
  SalePrice ~ Neighborhood,
  data = training.data,
  subset = Neighborhood %in% c("StoneBr", "NridgHt", "NoRidge")
)
```

Thus, we will classify neighborhoods as
```{r}
nbd.map <-
  data.frame(Neighborhood = X[order(X$avg.price), "Neighborhood"],
             nbd.class = c(rep(1, 3), rep(2, 3), rep(3, 6), rep(4, 5), rep(5, 5), rep(6, 3)))
nbd.map$nbd.class <- as.factor(nbd.map$nbd.class)
rm(X)
```

We will now use the new neighborhood classes and find out if sale price 
continues to be well resolved.
```{r}
X <- merge(training.data, nbd.map)[, c("nbd.class", "SalePrice")]
oneway.test(SalePrice ~ class, data = X)
```

The average sale prices are
```{r}
aggregate(cbind(avg.price = SalePrice) ~ class, data = X, mean)
```

We confirm that the neighborhood classes 2 and 3 are indeed different.
```{r}
oneway.test(SalePrice ~ class, data = X, subset = class %in% c(2, 3))
```

Before closing, we check the box plot of sale prices with new classes.
```{r}
bwplot(SalePrice ~ nbd.class, X)
rm(X, nbd.map)
```

We retain Neighborhood after collapsing $25$ levels into $6$.

## Condition1
We sort the levels by average sale price.
```{r}
X <- aggregate(cbind(avg.price = SalePrice) ~ Condition1,
               training.data,
               mean)
X[order(X$avg.price), ]
```

We explore if we can have three levels instead of nine.
```{r}
oneway.test(
  SalePrice ~ Condition1,
  data = training.data,
  subset = Condition1 %in% c("Artery", "RRAe", "Feedr")
)
oneway.test(
  SalePrice ~ Condition1,
  data = training.data,
  subset = Condition1 %in% c("RRNe", "Norm", "RRAn")
)
oneway.test(
  SalePrice ~ Condition1,
  data = training.data,
  subset = Condition1 %in% c("RRNn", "PosN", "PosA")
)
```

We will now confirm that this grouping of levels of Condition1 resolves sale 
price.
```{r}
cond1.map = data.frame(Condition1 = X[order(X$avg.price), "Condition1"],
                      cond1.class = c(rep(1, 3), rep(2, 3), rep(3, 3)))
cond1.map$cond1.class <- as.factor(cond1.map$cond1.class)
rm(X)
X <- merge(training.data, cond1.map)[, c("cond1.class", "SalePrice")]
oneway.test(SalePrice ~ cond1.class, X)
```

A distribution of sale prices across the new classes is
```{r}
bwplot(SalePrice ~ cond1.class, X)
rm(X, cond1.map)
```

Thus, we retain Condition1 after reducing nine levels to three.

## BldgType
We can possibly have only two types of buildings.
```{r}
X <- aggregate(cbind(avg.price = SalePrice) ~ BldgType, training.data, mean)
X[order(X$avg.price), ]
```

We will use the following mapping.
```{r}
bldgtype.map <- data.frame(BldgType = X[order(X$avg.price), "BldgType"],
                           BldgType.class = c(rep(1, 3), rep(2, 2)))
rm(X)
X <- merge(training.data, bldgtype.map)[, c("BldgType.class", "SalePrice")]
aggregate(cbind(avg.price = SalePrice) ~ BldgType.class, X, mean)
oneway.test(SalePrice ~ BldgType.class, X)
```

Let us see a distribution of prices across the new classes.
```{r}
bwplot(BldgType.class ~ SalePrice, X)
```

```{r}
rm(X, bldgtype.map)
```

Thus, we can collapse five levels of BldgType into two.

## HouseStyle
We can reduce the levels in HouseStyle as well.
```{r}
X <- aggregate(cbind(avg.price = SalePrice) ~ HouseStyle, training.data, mean)
X[order(X$avg.price), ]
```

Choosing the right group of variables will need a closer examination.
```{r}
oneway.test(SalePrice ~ HouseStyle,
            data = training.data,
            subset = HouseStyle %in% c("1.5Unf", "SFoyer"))
oneway.test(
  SalePrice ~ HouseStyle,
  data = training.data,
  subset = HouseStyle %in% c("1.5Unf", "SFoyer", "1.5Fin")
)
```

These are not the right groupings.
```{r}
oneway.test(SalePrice ~ HouseStyle,
            data = training.data,
            subset = HouseStyle %in% c("SFoyer", "1.5Fin"))
oneway.test(
  SalePrice ~ HouseStyle,
  data = training.data,
  subset = HouseStyle %in% c("SFoyer", "1.5Fin", "2.5Unf")
)
oneway.test(
  SalePrice ~ HouseStyle,
  data = training.data,
  subset = HouseStyle %in% c("SFoyer", "1.5Fin", "2.5Unf", "SLvl")
)
oneway.test(SalePrice ~ HouseStyle,
            data = training.data,
            subset = HouseStyle %in% c("2.5Unf", "SLvl"))
```

The groups so far are, {"1.5Unf"}, {"SFoyer", "1.5Fn"}, {"2.5Unf", "SLvl"}.
```{r}
oneway.test(SalePrice ~ HouseStyle, data = training.data, subset = HouseStyle %in% c("2.5Unf", "SLvl"))
```

I am not seeing a satisfactory grouping evolve. A distribution of prices across
building types is
```{r}
bwplot(SalePrice ~ HouseStyle, data = training.data)
```

A wide overlap of prices across house styles and a large number of outliers
suggests that HouseStyle is probably not a good predictor of sale price.

## Overall condition and quality
We first check if there is a correlation between the two.
```{r}
with(training.data, table(OverallCond, OverallQual))
```

This does not give much insight. It would be nice to see the mean instead.
```{r}
X <- with(training.data, tapply(SalePrice, list(OverallCond, OverallQual), mean))
```

Row wise range of average sale price is
```{r}
Xr <- apply(X, 1, function(x) range(x, na.rm = TRUE))
Xr[2, ] - Xr[1, ]
```

Column wise range of average sale price is
```{r}
Xc <- apply(X, 2, function(x) range(x, na.rm = TRUE))
Xc[2, ] - Xc[1, ]
```

Column-wise range is narrower than row-wise range. Therefore, we will use overall
quality instead of overall condition in our analysis.

How do the group means look like?
```{r}
rm(X, Xc, Xr)
X <-
  aggregate(cbind(avg.price = SalePrice) ~ OverallQual, 
            training.data, mean)[, c("OverallQual", "avg.price")]
X[order(X$avg.price),]
```

Let us check if the classes 1 and 2 could be combined?
```{r}
oneway.test(SalePrice ~ OverallQual, 
            data = training.data, 
            subset = OverallQual %in% c(1, 2))
```

There is a strong evidence that they are the same. Although this looks like a 
great predictor, we will still review a distribution of sale price across its 
levels after combining levels 1 and 2.
```{r}
overall.qual.map <- 
  data.frame(OverallQual = X[order(X$avg.price), "OverallQual"],
             overall.qual.class = c(2, 2, 3, 4, 5, 6, 7, 8 ,9 ,10))
rm(X)
X <- merge(training.data, overall.qual.map)[, c("overall.qual.class", "SalePrice")]
X$overall.qual.class <- as.factor(X$overall.qual.class)
bwplot(SalePrice ~ overall.qual.class, X)
rm(X, overall.qual.map)
```

This looks quite good.